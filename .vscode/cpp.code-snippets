{
	// Place your cp workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"for": {
		"scope": "cpp",
		"prefix": "for",
		"body": [
			"for(int ${1:i} = ${2:0}; $1 < ${3:n}; ++$1) {",
			"    $0",
			"}"
		],
		"description": "for loop"
	},
	"rfor": {
		"scope": "cpp",
		"prefix": "rfor",
		"body": [
			"for(int ${1:i} = ${2:n - 1}; $1 >= ${3:0}; --$1) {",
			"    $0",
			"}"
		],
		"description": "reversed for loop"
	},
    "ModInt": {
		"scope": "cpp",
        "prefix": "ModInt",
        "body": [
            "\r",
            "template <int MOD>\r",
            "struct ModInt {\r",
            "    int value;\r",
            "\r",
            "    ModInt(long long v = 0) {\r",
            "        value = v % MOD;\r",
            "        if (value < 0) value += MOD;\r",
            "    }\r",
            "\r",
            "    ModInt &operator+=(ModInt const &b) {\r",
            "        value += b.value;\r",
            "        if (value >= MOD) value -= MOD;\r",
            "        return *this;\r",
            "    }\r",
            "\r",
            "    ModInt &operator-=(ModInt const &b) {\r",
            "        value -= b.value;\r",
            "        if (value < 0) value += MOD;\r",
            "        return *this;\r",
            "    }\r",
            "\r",
            "    ModInt &operator*=(ModInt const &b) {\r",
            "        value = (long long)value * b.value % MOD;\r",
            "        return *this;\r",
            "    }\r",
            "\r",
            "    ModInt &operator/=(const ModInt &b) { return *this *= b.inv(); }\r",
            "\r",
            "    friend ModInt operator+(ModInt a, ModInt const b) { return a += b; }\r",
            "\r",
            "    friend ModInt operator-(ModInt a, ModInt const b) { return a -= b; }\r",
            "\r",
            "    friend ModInt operator-(ModInt const a) { return 0 - a; }\r",
            "\r",
            "    friend ModInt operator*(ModInt a, ModInt const b) { return a *= b; }\r",
            "\r",
            "    friend ModInt operator/(ModInt a, ModInt const b) { return a /= b; }\r",
            "\r",
            "    friend ostream &operator<<(std::ostream &os, ModInt const &a) { return os << a.value; }\r",
            "\r",
            "    friend bool operator==(ModInt const &a, ModInt const &b) { return a.value == b.value; }\r",
            "\r",
            "    friend bool operator!=(ModInt const &a, ModInt const &b) { return a.value != b.value; }\r",
            "\r",
            "    ModInt &operator++() {\r",
            "        *this += 1;\r",
            "        return *this;\r",
            "    }\r",
            "\r",
            "    ModInt operator++(int) {\r",
            "        ModInt old = *this;\r",
            "        operator++();\r",
            "        return old;\r",
            "    }\r",
            "\r",
            "    ModInt &operator--() {\r",
            "        *this -= 1;\r",
            "        return *this;\r",
            "    }\r",
            "\r",
            "    ModInt operator--(int) {\r",
            "        ModInt old = *this;\r",
            "        operator--();\r",
            "        return old;\r",
            "    }\r",
            "\r",
            "    ModInt pow(long long e) const {\r",
            "        if (e < 0) return inv().pow(-e);\r",
            "        ModInt a = *this, res = 1;\r",
            "        while (e) {\r",
            "            if (e & 1) res *= a;\r",
            "            a *= a;\r",
            "            e >>= 1;\r",
            "        }\r",
            "        return res;\r",
            "    }\r",
            "\r",
            "    ModInt inv() const { return pow(MOD - 2); }\r",
            "};\r",
            "\r",
            "const int MOD = 1e9 + 7;\r",
            "\r",
            "typedef ModInt<MOD> mint;\r",
            "typedef vector<mint> vmi;\r",
            "typedef vector<vmi> vvmi;\r",
            ""
        ],
        "description": "ModInt"
    },
    "cp": {
        "prefix": "cp",
        "body": [
            "#include \"bits/stdc++.h\"\r",
            "\r",
            "#ifdef COTATO\r",
            "\r",
            "#include \"templates/others/dbg.cpp\"\r",
            "\r",
            "#else\r",
            "#define dbg(...)\r",
            "#define dbgln(...)\r",
            "#endif\r",
            "\r",
            "using namespace std;\r",
            "\r",
            "typedef long long ll;\r",
            "typedef pair<int, int> pii;\r",
            "typedef pair<ll, ll> pll;\r",
            "typedef queue<int> qi;\r",
            "typedef vector<int> vi;\r",
            "typedef vector<vector<int>> vvi;\r",
            "typedef vector<ll> vll;\r",
            "typedef vector<vector<ll>> vvll;\r",
            "typedef vector<bool> vb;\r",
            "typedef vector<vector<bool>> vvb;\r",
            "typedef vector<pii> vpii;\r",
            "typedef vector<pll> vpll;\r",
            "typedef vector<vector<pll>> vvpll;\r",
            "typedef vector<char> vc;\r",
            "typedef vector<vector<char>> vvc;\r",
            "typedef vector<string> vs;\r",
            "typedef set<int> si;\r",
            "typedef set<ll> sll;\r",
            "typedef map<int, int> mii;\r",
            "typedef map<ll, ll> mll;\r",
            "#define fast ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr)\r",
            "#define endl '\\n'\r",
            "#define all(a) a.begin(), a.end()\r",
            "#define yes \"YES\"\r",
            "#define no \"NO\"\r",
            "#define spc ' '\r",
            "#define INF INT_MAX\r",
            "#define LLINF LONG_LONG_MAX\r",
            "#define NINF INT_MIN\r",
            "#define LLNINF LONG_LONG_MIN\r",
            "#define pb push_back\r",
            "#define pf push_front\r",
            "#define eb emplace_back\r",
            "#define F first\r",
            "#define S second\r",
            "#define cin(a) \\\r",
            "    for (auto &_x : (a)) cin >> _x\r",
            "#define cin2(a)          \\\r",
            "    for (auto &_x : (a)) \\\r",
            "        for (auto &__x : _x) cin >> __x\r",
            "#define cout(a) \\\r",
            "    for (auto &_x : (a)) cout << _x << spc\r",
            "#define len(l, r) ((r) - (l) + 1)\r",
            "#define mid(l, r) ((l) + ((r) - (l)) / 2)\r",
            "#define ceil(a, b) (!(a) ? 0 : ((a)-1) / (b) + 1)\r",
            "#define yn(b) ((b) ? yes : no)\r",
            "#define between(x, l, r) ((x) >= (l) && (x) <= (r))\r",
            "#define between2(i, j, n, m) (between(i, 0, n - 1) && between(j, 0, m - 1))\r",
            "\r",
            "void solve() {\r",
            "}\r",
            "\r",
            "#define MULTI\r",
            "\r",
            "int main() {\r",
            "    fast;\r",
            "    int t = 1;\r",
            "#ifdef MULTI\r",
            "    cin >> t;\r",
            "#endif\r",
            "    for (int i = 1; i <= t; ++i) {\r",
            "        solve();\r",
            "        i != t &&cout << endl;\r",
            "    }\r",
            "}\r",
            "/*\r",
            "\r",
            "\r",
            "\r",
            " */"
        ],
        "description": "cp"
    },
    "vdir": {
        "prefix": "vdir",
        "body": [
            "vpii dir = {",
            "    {0, 1},",
            "    {0, -1},",
            "    {1, 0},",
            "    {-1, 0},",
            "};",
            ""
        ],
        "description": "vdir"
    },
    "UF": {
        "prefix": "UF",
        "body": [
            "struct UF {\r",
            "   private:\r",
            "    vi p, size;\r",
            "    int cc;\r",
            "\r",
            "   public:\r",
            "    UF(int n) {\r",
            "        p = vi(n);\r",
            "        size = vi(n, 1);\r",
            "        iota(all(p), 0);\r",
            "        cc = n;\r",
            "    }\r",
            "\r",
            "    int find(int u) {\r",
            "        return p[u] == u ? u : p[u] = find(p[u]);\r",
            "    }\r",
            "\r",
            "    bool join(int u, int v) {\r",
            "        u = find(u), v = find(v);\r",
            "        if (u == v) return false;\r",
            "        if (size[u] < size[v]) swap(u, v);\r",
            "        p[v] = u;\r",
            "        size[u] += size[v];\r",
            "        --cc;\r",
            "        return true;\r",
            "    }\r",
            "\r",
            "    bool connected(int u, int v) {\r",
            "        return find(u) == find(v);\r",
            "    }\r",
            "\r",
            "    int getSize(int u) {\r",
            "        return size[find(u)];\r",
            "    }\r",
            "\r",
            "    int getCC() const {\r",
            "        return cc;\r",
            "    }\r",
            "};\r",
            ""
        ],
        "description": "UF"
    },
    "RollbackUF": {
        "prefix": "RollbackUF",
        "body": [
            "struct RollbackUF {\r",
            "   private:\r",
            "    vector<int> data;\r",
            "    stack<pair<int, int>> history;\r",
            "    int cc;\r",
            "\r",
            "    void snapshot(int u, int v) {\r",
            "        history.emplace(u, data[u]);\r",
            "        history.emplace(v, data[v]);\r",
            "        history.emplace(-1, cc);\r",
            "    }\r",
            "\r",
            "   public:\r",
            "    RollbackUF(int n) {\r",
            "        data.assign(n, -1);\r",
            "        cc = n;\r",
            "    }\r",
            "\r",
            "    int find(int u) {\r",
            "        return data[u] < 0 ? u : find(data[u]);\r",
            "    }\r",
            "\r",
            "    bool join(int u, int v) {\r",
            "        u = find(u), v = find(v);\r",
            "        if (u == v) return false;\r",
            "        snapshot(u, v);\r",
            "        if (data[u] > data[v]) swap(u, v);\r",
            "        data[u] += data[v];\r",
            "        data[v] = u;\r",
            "        --cc;\r",
            "        return true;\r",
            "    }\r",
            "\r",
            "    bool connected(int u, int v) { return find(u) == find(v); }\r",
            "\r",
            "    int getSize(int u) { return (-data[find(u)]); }\r",
            "\r",
            "    int getCC() { return cc; }\r",
            "\r",
            "    void undo() {\r",
            "        cc = history.top().second;\r",
            "        history.pop();\r",
            "        data[history.top().first] = history.top().second;\r",
            "        history.pop();\r",
            "        data[history.top().first] = history.top().second;\r",
            "        history.pop();\r",
            "    }\r",
            "};\r",
            ""
        ],
        "description": "Rollback Union Find"
},   
    "FT": {
        "prefix": "FT",
        "body": [
            "template <class T = int>\r",
            "struct FT {\r",
            "    int n;\r",
            "    vector<T> t;\r",
            "\r",
            "    FT(int n) {\r",
            "        this->n = n + 1;\r",
            "        t.resize(n + 1);\r",
            "    }\r",
            "\r",
            "    FT(vector<T> &a) : FT(a.size()) {\r",
            "        for (int i = 1; i <= a.size(); ++i) {\r",
            "            t[i] += a[i - 1];\r",
            "            int j = i + (i & -i);\r",
            "            if (j < n + 1) t[j] += t[i];\r",
            "        }\r",
            "    }\r",
            "\r",
            "    void add(int i, T x) {\r",
            "        for (++i; i < n; i += i & -i) t[i] += x;\r",
            "    }\r",
            "\r",
            "    T sum(int l, int r) {\r",
            "        return sum(r) - sum(l - 1);\r",
            "    }\r",
            "\r",
            "    T sum(int i) {\r",
            "        T res = 0;\r",
            "        for (++i; i; i -= i & -i) res += t[i];\r",
            "        return res;\r",
            "    }\r",
            "};\r",
            ""
        ],
        "description": "FT"
    },
    "FT2D": {
        "prefix": "FT2D",
        "body": [
            "template <class T = int>\r",
            "struct FT2D {\r",
            "    int n, m;\r",
            "    vector<vector<T>> t;\r",
            "\r",
            "    FT2D(int n, int m) {\r",
            "        this->n = n + 1;\r",
            "        this->m = m + 1;\r",
            "        t.resize(n + 1, vector<T>(m + 1));\r",
            "    }\r",
            "\r",
            "    FT2D(vector<vector<T>> &a) : FT2D(a.size(), a.front().size()) {\r",
            "        for (int i = 1; i <= a.size(); ++i) {\r",
            "            for (int j = 1; j <= a.front().size(); ++j) {\r",
            "                t[i][j] += a[i - 1][j - 1];\r",
            "                int ii = i + (i & -i);\r",
            "                int jj = j + (j & -j);\r",
            "                if (ii < n + 1) t[ii][j] += t[i][j];\r",
            "                if (jj < m + 1) t[i][jj] += t[i][j];\r",
            "                if (ii < n + 1 && jj < m + 1) t[ii][jj] -= t[i][j];\r",
            "            }\r",
            "        }\r",
            "    }\r",
            "\r",
            "    void add(int x, int y, T v) {\r",
            "        for (int i = x + 1; i < n; i += i & -i) {\r",
            "            for (int j = y + 1; j < m; j += j & -j) {\r",
            "                t[i][j] += v;\r",
            "            }\r",
            "        }\r",
            "    }\r",
            "\r",
            "    //          top left        bottom right\r",
            "    T sum(int x1, int y1, int x2, int y2) {\r",
            "        return sum(x2, y2) + sum(x1 - 1, y1 - 1) -\r",
            "               sum(x1 - 1, y2) - sum(x2, y1 - 1);\r",
            "    }\r",
            "\r",
            "    T sum(int x, int y) {\r",
            "        T res = 0;\r",
            "        for (int i = x + 1; i; i -= i & -i) {\r",
            "            for (int j = y + 1; j; j -= j & -j) {\r",
            "                res += t[i][j];\r",
            "            }\r",
            "        }\r",
            "        return res;\r",
            "    }\r",
            "};\r",
            ""
        ],
        "description": "FT2D"
    },
    "ST": {
        "prefix": "ST",
        "body": [
            "struct ST {\r",
            "    struct D {\r",
            "        ll v = 0;\r",
            "        D() {}\r",
            "        D(ll v) : v(v) {}\r",
            "        void reset() {\r",
            "            v = 0;\r",
            "        }\r",
            "        // combine\r",
            "        D operator+=(const D &x) {\r",
            "            v += x.v;\r",
            "            return *this;\r",
            "        }\r",
            "        // accumulating D over a segment of length x\r",
            "        D operator*(const int x) {\r",
            "            return {v * x};\r",
            "        }\r",
            "        // return true if nothing to propagate\r",
            "        bool operator!() {\r",
            "            return !v;\r",
            "        }\r",
            "    };\r",
            "\r",
            "    struct T {\r",
            "        ll v = 0;\r",
            "        // combine\r",
            "        T operator+(const T &that) const {\r",
            "            return {v + that.v};\r",
            "        }\r",
            "        // combine with lazy\r",
            "        T operator+=(const D &d) {\r",
            "            v += d.v;\r",
            "            return *this;\r",
            "        }\r",
            "        // the final useful piece of info we're interested in\r",
            "        // make sure the return type matches the actual type of the returned value\r",
            "        ll res() {\r",
            "            return v;\r",
            "        }\r",
            "    };\r",
            "\r",
            "    int n, h;\r",
            "    vector<T> t;\r",
            "    vector<D> d;\r",
            "    vi ln;\r",
            "\r",
            "    ST(int n) {\r",
            "        this->n = n;\r",
            "        this->h = 31 - countl_zero(unsigned(n));\r",
            "        t.resize(n << 1);\r",
            "        ln.resize(n << 1);\r",
            "        d.resize(n);\r",
            "        for (int i = 0; i < n; ++i) ln[i + n] = 1;\r",
            "        for (int i = n - 1; i; --i) ln[i] = ln[i << 1] + ln[i << 1 | 1];\r",
            "    }\r",
            "    ST(vi &a) : ST(a.size()) {\r",
            "        for (int i = 0; i < n; ++i) t[i + n] = T(a[i]);\r",
            "        for (int i = n - 1; i; --i) calc(i);\r",
            "    }\r",
            "    void update(int l, int r, D x) {\r",
            "        l += n, r += n + 1;\r",
            "        int l0 = l, r0 = r;\r",
            "        push(l, r);\r",
            "        for (; l < r; l >>= 1, r >>= 1) {\r",
            "            if (l & 1) apply(l++, x);\r",
            "            if (r & 1) apply(--r, x);\r",
            "        }\r",
            "        pull(l0, r0);\r",
            "    }\r",
            "    T query(int l, int r) {\r",
            "        l += n, r += n + 1;\r",
            "        push(l, r);\r",
            "        T resl, resr;\r",
            "        for (; l < r; l >>= 1, r >>= 1) {\r",
            "            if (l & 1) resl = resl + t[l++];\r",
            "            if (r & 1) resr = t[--r] + resr;\r",
            "        }\r",
            "        return resl + resr;\r",
            "    }\r",
            "\r",
            "   private:\r",
            "    void calc(int i) {\r",
            "        t[i] = t[i << 1] + t[i << 1 | 1];\r",
            "    }\r",
            "    void apply(int i, D x) {\r",
            "        t[i] += x * ln[i];\r",
            "        if (i < n) d[i] += x;\r",
            "    }\r",
            "    void push(int i) {\r",
            "        if (!d[i]) return;\r",
            "        apply(i << 1, d[i]);\r",
            "        apply(i << 1 | 1, d[i]);\r",
            "        d[i].reset();\r",
            "    }\r",
            "    void push(int l, int r) {\r",
            "        for (int i = h; i; --i) {\r",
            "            if (l >> i << i != l) push(l >> i);\r",
            "            if (r >> i << i != r) push(r >> i);\r",
            "        }\r",
            "    }\r",
            "    void pull(int l, int r) {\r",
            "        for (int i = 1; i <= h; ++i) {\r",
            "            if (l >> i << i != l) calc(l >> i);\r",
            "            if (r >> i << i != r) calc(r >> i);\r",
            "        }\r",
            "    }\r",
            "};\r",
            ""
        ],
        "description": "ST"
    },
    "PST": {
        "prefix": "PST",
        "body": [
            "const int _MAX = 2e5 + 1;",
            "int idx = 0;",
            "struct N {",
            "    int l, r, s;",
            "} nodes[22 * _MAX];",
            "int create(int s) {",
            "    nodes[idx].s = s;",
            "    return idx++;",
            "}",
            "int merge(int l, int r) {",
            "    nodes[idx].l = l;",
            "    nodes[idx].r = r;",
            "    nodes[idx].s = 0;",
            "    if (l != -1) nodes[idx].s += nodes[l].s;",
            "    if (r != -1) nodes[idx].s += nodes[r].s;",
            "    return idx++;",
            "}",
            "struct PST {",
            "    int n;",
            "    int *roots;",
            "    PST(int n, vi &a) {",
            "        this->n = n;",
            "        roots = new int[a.size() + 1];",
            "        roots[0] = build(0, n - 1);",
            "        for (int i = 0; i < a.size(); ++i) {",
            "            roots[i + 1] = update(roots[i], 0, n - 1, a[i]);",
            "        }",
            "    }",
            "    int build(int l, int r) {",
            "        if (l == r) return create(0);",
            "        int m = mid(l, r);",
            "        return merge(build(l, m), build(m + 1, r));",
            "    }",
            "    int update(int n, int l, int r, int at) {",
            "        if (l == r) return create(nodes[n].s + 1);",
            "        int m = mid(l, r);",
            "        if (at <= m) return merge(update(nodes[n].l, l, m, at), nodes[n].r);",
            "        return merge(nodes[n].l, update(nodes[n].r, m + 1, r, at));",
            "    }",
            "    int query(int l, int r, int x) {",
            "        return query(roots[l], roots[r + 1], x, n - 1, 0, n - 1);",
            "    }",
            "    int query(int nl, int nr, int ql, int qr, int l, int r) {",
            "        if (l > qr || r < ql) return 0;",
            "        if (l >= ql && r <= qr) return nodes[nr].s - nodes[nl].s;",
            "        int m = mid(l, r);",
            "        return query(nodes[nl].l, nodes[nr].l, ql, qr, l, m) +",
            "               query(nodes[nl].r, nodes[nr].r, ql, qr, m + 1, r);",
            "    }",
            "};",
            ""
        ],
        "description": "PST"
    },
    "HASH": {
        "prefix": "HASH",
        "body": [
            "const int HASH_CNT = 2;\r",
            "static_assert(HASH_CNT <= 2);\r",
            "typedef __int128 lll;\r",
            "typedef array<lll, HASH_CNT> H;\r",
            "const lll P[2] = {53, 59};\r",
            "const lll M[2] = {984162944621615729, 984162944621615797};\r",
            "H hsh(const string &s) {\r",
            "    H res, p;\r",
            "    for (int i = 0; i < HASH_CNT; ++i) res[i] = 0, p[i] = 1;\r",
            "    for (auto c : s) {\r",
            "        for (int i = 0; i < HASH_CNT; ++i) {\r",
            "            res[i] += (c - 'a' + 1) * p[i] % M[i];\r",
            "            p[i] = p[i] * P[i] % M[i];\r",
            "        }\r",
            "    }\r",
            "    return res;\r",
            "}\r",
            ""
        ],
        "description": "HASH"
    },    "TRIE": {
    "prefix": "TRIE",
        "body": [
            "struct Trie {\r",
            "    struct N {\r",
            "        char key;\r",
            "        bool end;\r",
            "        N *l, *m, *r;\r",
            "        bool isErasable() {\r",
            "            return !end && !l && !m && !r;\r",
            "        }\r",
            "    };\r",
            "    int sz = 0;\r",
            "    N *root = 0;\r",
            "    void insert(const string &s) {\r",
            "        insert(root, 0, s);\r",
            "    }\r",
            "    void insert(N *&u, int i, const string &s) {\r",
            "        if (!u) u = new N{s[i]};\r",
            "        if (s[i] < u->key) return insert(u->l, i, s);\r",
            "        if (s[i] > u->key) return insert(u->r, i, s);\r",
            "        if (i < s.length() - 1) return insert(u->m, i + 1, s);\r",
            "        sz += !u->end;\r",
            "        u->end = true;\r",
            "    }\r",
            "    void erase(const string &s) {\r",
            "        erase(root, 0, s);\r",
            "    }\r",
            "    void erase(N *&u, int i, const string &s) {\r",
            "        if (!u) return;\r",
            "        if (s[i] < u->key)\r",
            "            erase(u->l, i, s);\r",
            "        else if (s[i] > u->key)\r",
            "            erase(u->r, i, s);\r",
            "        else if (i < s.length() - 1)\r",
            "            erase(u->m, i + 1, s);\r",
            "        else {\r",
            "            sz -= u->end;\r",
            "            u->end = false;\r",
            "        }\r",
            "        if (u->isErasable()) {\r",
            "            delete u;\r",
            "            u = 0;\r",
            "        }\r",
            "    }\r",
            "    int size() {\r",
            "        return sz;\r",
            "    }\r",
            "};\r",
            ""
        ],
        "description": "TRIE"
    },
    "MatrixExponentiation": {
        "prefix": "MatrixExponentiation",
        "body": [
            "template <class T = int, int N = 2>\r",
            "struct Matrix {\r",
            "    T a[N][N];\r",
            "    Matrix operator*(Matrix &that) {\r",
            "        Matrix<T, N> res;\r",
            "        for (int k = 0; k < N; ++k) {\r",
            "            for (int i = 0; i < N; ++i) {\r",
            "                for (int j = 0; j < N; ++j) {\r",
            "                    res.a[i][j] += a[i][k] * that.a[k][j];\r",
            "                }\r",
            "            }\r",
            "        }\r",
            "        return res;\r",
            "    }\r",
            "    Matrix pow(ll n) {\r",
            "        Matrix<T, N> a = *this;\r",
            "        Matrix<T, N> res;\r",
            "        for (int i = 0; i < N; ++i) {\r",
            "            res.a[i][i] = 1;\r",
            "        }\r",
            "        while (n) {\r",
            "            if (n & 1) res = res * a;\r",
            "            a = a * a;\r",
            "            n >>= 1;\r",
            "        }\r",
            "        return res;\r",
            "    }\r",
            "};\r",
            ""
        ],
        "description": "MatrixExponentiation"
    }
}